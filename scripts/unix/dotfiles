#!/usr/bin/env bash
# This script was generated by bashly 1.1.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

version_command() {
  echo "$version"
}

dotfiles_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles - CLI tool for managing dotfiles with chezmoi\n"
    echo

  else
    printf "dotfiles - CLI tool for managing dotfiles with chezmoi\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles COMMAND\n"
  printf "  dotfiles [COMMAND] --help | -h\n"
  printf "  dotfiles --version | -v\n"
  echo

  printf "%s\n" "Commands:"
  printf "  %s   Shell to generate completion\n" "completion"
  printf "  %s   Download dotfiles from the internet\n" "download  "
  printf "  %s   Install dotfiles with chezmoi\n" "install   "
  printf "  %s   Update dotfiles with chezmoi\n" "update    "
  printf "  %s   Edit dotfiles\n" "edit      "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

dotfiles_completion_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles completion - Shell to generate completion\n"
    echo

  else
    printf "dotfiles completion - Shell to generate completion\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles completion\n"
  printf "  dotfiles completion --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

dotfiles_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles download - Download dotfiles from the internet\n"
    echo

  else
    printf "dotfiles download - Download dotfiles from the internet\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles download [TARGET] [OPTIONS]\n"
  printf "  dotfiles download --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--repo, -r REPO"
    printf "    Repo to download from\n"
    printf "    Default: Nitestack/dotfiles\n"
    echo

    printf "  %s\n" "--branch, -b BRANCH"
    printf "    Branch to download from\n"
    printf "    Default: master\n"
    echo

    printf "  %s\n" "--ssh"
    printf "    Use SSH instead of HTTPS\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "TARGET"
    printf "    Target directory to download to\n"
    printf "    Default: ~/.dotfiles\n"
    echo

  fi
}

dotfiles_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles install - Install dotfiles with chezmoi\n"
    echo

  else
    printf "dotfiles install - Install dotfiles with chezmoi\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles install [SOURCEDIR] [OPTIONS]\n"
  printf "  dotfiles install --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--one-shot"
    printf "    Attempts to install your dotfiles with chezmoi and then remove all traces of\n    chezmoi from the system. This is useful for setting up temporary\n    environments (e.g. Docker containers).\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "SOURCEDIR"
    printf "    Source directory of dotfiles\n"
    printf "    Default: ~/.dotfiles\n"
    echo

  fi
}

dotfiles_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles update - Update dotfiles with chezmoi\n"
    echo

  else
    printf "dotfiles update - Update dotfiles with chezmoi\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles update [OPTIONS]\n"
  printf "  dotfiles update --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--refresh-externals, -R OPTION"
    printf "    Refresh external cache. This defaults to auto.\n"
    printf "    Allowed: always, auto, never\n"
    printf "    Default: auto\n"
    echo

    printf "  %s\n" "--local, -l"
    printf "    Apply local changes with \`chezmoi apply\`.\n"
    echo

    printf "  %s\n" "--cli"
    printf "    Update the CLI itself. This defaults to false.\n"
    echo

    printf "  %s\n" "--nvim"
    printf "    Update Neovim plugins, Mason packages and sync lazy-lock.json file if it\n    exists.\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

dotfiles_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles edit - Edit dotfiles\n"
    echo

  else
    printf "dotfiles edit - Edit dotfiles\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles edit [TARGET] [OPTIONS]\n"
  printf "  dotfiles edit --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--neovide, -n"
    printf "    Use Neovide (Neovim GUI) instead of Neovim\n"
    echo

    printf "  %s\n" "--apply, -a"
    printf "    Apply target immediately after editing. Ignored if there are no targets.\n"
    echo

    printf "  %s\n" "--hardlink BOOL"
    printf "    Invoke the editor with a hard link to the source file with a name matching\n    the target filename. This can help the editor determine the type of the file\n    correctly. This is the default.\n"
    printf "    Allowed: true, false\n"
    echo

    printf "  %s\n" "--watch, -w"
    printf "    Automatically apply changes when files are saved\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "TARGET"
    printf "    Target file to edit\n"
    printf "    Default: \n"
    echo

  fi
}

normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

expand_tilde() {
	local path="$1"
	eval echo "${path}"
}

log_color() {
	local color_code="$1"
	shift

	printf "\033[${color_code}m%s\033[0m\n" "$*" >&2
}
log_green() {
	log_color "0;32" "$@"
}
log_yellow() {
	log_color "0;33" "$@"
}
start_task() {
	log_yellow "󰪥" "$@"
}
complete_task() {
	log_green "" "$@"
}

send_completions() {
  echo $'# dotfiles completion                                      -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_dotfiles_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_dotfiles_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'update\'*\'--refresh-externals\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "always auto never")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'edit\'*\'--hardlink\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "true false")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'completion\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'update\'*\'-R\')'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "always auto never")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'download\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "--branch --help --repo --ssh -b -h -r")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'install\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "--help --one-shot -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'update\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "--cli --help --local --nvim --refresh-externals -R -h -l")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'edit\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "--apply --hardlink --help --neovide --watch -a -h -n -w")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_dotfiles_completions_filter "--help --version -h -v completion download edit install update")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _dotfiles_completions dotfiles'
  echo $''
  echo $'# ex: filetype=sh'
}

show_spinner() {
	local task="$1"
	local start_message="$2"
	local completion_message="$3"
	local error_message="${4:-An unexpected error occurred}"

	local spinner_frames=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

	display_spinner() {
		local pid=$!
		local i=0
		tput civis # Hide cursor

		while kill -0 "${pid}" 2>/dev/null; do
			printf "\r\e[33m%s %s\e[0m" "${spinner_frames[i]}" "${start_message}" # Yellow color
			i=$(((i + 1) % ${#spinner_frames[@]}))
			sleep 0.1
		done

		tput cnorm # Show cursor
	}

	# Run the task in the background, redirect stdout and stderr to separate temporary files
	local temp_out_log=$(mktemp)
	local temp_err_log=$(mktemp)
	(${task} >"${temp_out_log}" 2>"${temp_err_log}") &

	display_spinner "${start_message}"

	# Wait for the task to complete
	wait $!
	local exit_code=$?

	# Print last frame of the spinner
	last_index=$((${#spinner_frames[@]} - 1))
	printf "\r\e[33m%s %s\e[0m" "${spinner_frames[${last_index}]}" "${start_message}" # Yellow color

	# Get the last echo message from the output log file
	local last_echo=$(tail -n 1 "${temp_out_log}")

	# Remove the last line of the output log file, if the exit code is greater than 1
	if [[ ${exit_code} -gt 1 ]]; then
		sed -i '$ d' "${temp_out_log}"
	fi

	# Display stdout logs if they are not empty
	if [[ -s "${temp_out_log}" ]]; then
		echo
		cat "${temp_out_log}"
	fi

	# Display stderr logs if they are not empty
	if [[ -s "${temp_err_log}" ]]; then
		echo
		cat "${temp_err_log}" | while IFS= read -r line; do echo -e "\033[31m${line}\033[0m"; done
	fi

	# Clear the line before displaying the final message
	printf "\r\033[K"

	# Display completion or error message based on exit code
	if [[ ${exit_code} -eq 0 ]]; then
		printf "\r\e[32m%s %s\e[0m\n" "󰗠" "${completion_message}" # Green color
	elif [[ ${exit_code} -eq 1 ]]; then
		printf "\r\e[31m%s %s\e[0m\n" "" "${error_message}" # Red color
	else
		printf "\r%s %s\n" "" "${last_echo}"
	fi

	# Clean up
	rm "${temp_out_log}" "${temp_err_log}"
}

validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

dotfiles_completion_command() {
  send_completions

}

dotfiles_download_command() {
  dotfiles_dir=$(expand_tilde "${args[target]}")
  repo=${args[--repo]}
  branch=${args[--branch]}
  ssh=${args[--ssh]}

  if [[ -n "${ssh}" ]]; then
  	remote="git@github.com:${repo}.git"
  else
  	remote="https://github.com/${repo}.git"
  fi

  if [[ -d "${dotfiles_dir}" ]]; then
  	path=$(realpath "${dotfiles_dir}")

  	clean_dotfiles() {
  		git="git -C ${path}"
  		if ${git} remote | grep -q "^origin$"; then
  			${git} remote set-url origin "${remote}"
  		else
  			${git} remote add origin "${remote}"
  		fi
  		${git} checkout -B "${branch}"
  		${git} fetch origin "${branch}"
  		${git} reset --hard FETCH_HEAD
  		${git} clean -fdx
  		unset path remote branch git
  	}

  	show_spinner "clean_dotfiles" "Cleaning '${path}' with '${remote}' at branch '${branch}'" "Dotfiles cleaned from '${path}'"
  else
  	clone_dotfiles() {
  		git clone -b "${branch}" "${remote}" "${dotfiles_dir}"
  	}
  	show_spinner "clone_dotfiles" "Cloning '${repo}' at branch '${branch}' to '${dotfiles_dir}'" "Dotfiles downloaded to '${dotfiles_dir}'"
  fi

}

dotfiles_install_command() {
  start_task "Installing dotfiles"

  sourceDir=$(expand_tilde "${args[sourceDir]}")

  set -- --source="${sourceDir}" --verbose=false

  if [[ -n "${args["--one-shot"]}" ]]; then
  	set -- "$@" --one-shot
  else
  	set -- "$@" --apply
  fi

  chezmoi init "$@"

  complete_task "Installed dotfiles"

}

dotfiles_update_command() {
  start_task "Updating dotfiles"

  if [[ -n "${args[--local]}" ]]; then
  	set -- apply
  else
  	set -- update
  fi

  if [[ -n "${args["--refresh-externals"]}" ]]; then
  	set -- "$@" --refresh-externals="${args["--refresh-externals"]}"
  fi

  chezmoi "$@"
  complete_task "Updated dotfiles"

  if [[ -n "${args["--cli"]}" ]]; then
  	update_cli() {
  		script_dir="$(cd -P -- "$(dirname -- "$(command -v -- "$0")")" && pwd -P)/dotfiles"
  		if [[ ! -f "${script_dir}" ]]; then
  			echo "Could not find '${script_dir}'"
  			exit 1
  		fi

  		updated_script_dir=$(realpath "$(chezmoi source-path)/../scripts/unix/dotfiles")
  		if [[ ! -f "${updated_script_dir}" ]]; then
  			echo "Could not find '${updated_script_dir}'"
  			exit 1
  		fi

  		if [[ "${script_dir}" == "${updated_script_dir}" ]]; then
  			echo "The CLI is already up to date"
  			exit 2
  		fi

  		cp -f "${updated_script_dir}" "${script_dir}"
  	}

  	show_spinner "update_cli" "Updating CLI" "Updated CLI"
  fi

  if [[ -n "${args["--nvim"]}" ]]; then
  	update_neovim() {
  		bob update --all
  	}
  	show_spinner "update_neovim" "Updating Neovim" "Updated Neovim"

  	update_neovim_plugins() {
  		nvim --headless -c "Lazy! sync" +qa
  	}
  	show_spinner "update_neovim_plugins" "Updating Neovim plugins" "Updated Neovim plugins"

  	update_mason_packages() {
  		nvim --headless -c "lua vim.schedule(function() vim.api.nvim_create_autocmd('User', { pattern = 'MasonToolsUpdateCompleted', command = 'qa' }); require('mason-tool-installer').check_install(true) end)"
  	}
  	show_spinner "update_mason_packages" "Updating Mason packages" "Updated Mason packages"

  	source_path=$(chezmoi source-path)
  	lazy_lock_path=$(find "${source_path}" -type f -name "*lazy-lock.json" -print -quit)
  	sync_lazy_lock() {
  		if [[ ! -f "${lazy_lock_path}" ]]; then
  			echo "Could not find 'lazy-lock.json' file in '${source_path}'"
  			exit 1
  		fi
  		config_path="${XDG_CONFIG_HOME:-${HOME}/.config}/nvim"
  		updated_lazy_lock_path=$(find "${config_path}" -type f -name "*lazy-lock.json" -print -quit)
  		if [[ ! -f "${updated_lazy_lock_path}" ]]; then
  			echo "Could not find 'lazy-lock.json' file in '${config_path}'"
  			exit 1
  		fi
  		cp -f "${updated_lazy_lock_path}" "${lazy_lock_path}"
  	}
  	show_spinner "sync_lazy_lock" "Syncing 'lazy-lock.json' file" "Synced 'lazy-lock.json' file"

  	commit_lazy_lock() {
  		current_path=$(pwd)
  		cd "$(realpath "$(chezmoi source-path)/..")" || exit 1
  		# Check if there are any changes
  		if git diff --quiet "${lazy_lock_path}"; then
  			echo "No changes in 'lazy-lock.json' file"
  			exit 2
  		fi
  		git add "${lazy_lock_path}"
  		git commit "${lazy_lock_path}" -m "chore(nvim): update lazy-lock.json"
  		cd "${current_path}" || exit 1
  	}
  	show_spinner "commit_lazy_lock" "Committing 'lazy-lock.json' file" "Committed 'lazy-lock.json' file"

  	lazyvim_path=$(find "${source_path}" -type f -name "*lazyvim.json" -print -quit)
  	sync_lazyvim() {
  		if [[ ! -f "${lazyvim_path}" ]]; then
  			echo "Could not find 'lazyvim.json' file in '${source_path}'"
  			exit 1
  		fi
  		config_path="${XDG_CONFIG_HOME:-${HOME}/.config}/nvim"
  		updated_lazyvim_path=$(find "${config_path}" -type f -name "*lazyvim.json" -print -quit)
  		if [[ ! -f "${updated_lazyvim_path}" ]]; then
  			echo "Could not find 'lazyvim.json' file in '${config_path}'"
  			exit 1
  		fi
  		cp -f "${updated_lazyvim_path}" "${lazyvim_path}"
  	}
  	show_spinner "sync_lazyvim" "Syncing 'lazyvim.json' file" "Synced 'lazyvim.json' file"

  	commit_lazyvim() {
  		current_path=$(pwd)
  		cd "$(realpath "$(chezmoi source-path)/..")" || exit 1
  		# Check if there are any changes
  		if git diff --quiet "${lazyvim_path}"; then
  			echo "No changes in 'lazyvim.json' file"
  			exit 2
  		fi
  		git add "${lazyvim_path}"
  		git commit "${lazyvim_path}" -m "chore(nvim): update lazyvim.json"
  		cd "${current_path}" || exit 1
  	}
  	show_spinner "commit_lazyvim" "Committing 'lazyvim.json' file" "Committed 'lazyvim.json' file"
  fi

}

dotfiles_edit_command() {
  if [[ "${#args[@]}" -eq 0 ]]; then
  	cd "$(realpath "$(chezmoi source-path)/..")" || exit 1

  	if [[ -n "${args[--neovide]}" ]] && command -v neovide &>/dev/null; then
  		neovide
  	elif command -v nvim &>/dev/null; then
  		nvim
  	fi
  else
  	set -- "${args[target]}"

  	if [[ -n "${args[--apply]}" ]]; then
  		set -- "$@" --apply
  	fi
  	if [[ -n "${args[--hardlink]}" ]]; then
  		set -- "$@" --hardlink="${args[--hardlink]}"
  	fi
  	if [[ -n "${args[--watch]}" ]]; then
  		set -- "$@" --watch
  	fi

  	chezmoi edit "$@"
  fi

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dotfiles_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v chezmoi >/dev/null 2>&1; then
    deps['chezmoi']="$(command -v chezmoi | head -n1)"
  else
    printf "missing dependency: chezmoi\n" >&2
    printf "%s\n" "Visit 'https://www.chezmoi.io/install' to install chezmoi" >&2
    exit 1
  fi

  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    printf "%s\n" "Visit 'https://git-scm.com/downloads' to install git" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    completion)
      action="completion"
      shift
      dotfiles_completion_parse_requirements "$@"
      shift $#
      ;;

    download)
      action="download"
      shift
      dotfiles_download_parse_requirements "$@"
      shift $#
      ;;

    install)
      action="install"
      shift
      dotfiles_install_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      dotfiles_update_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      dotfiles_edit_parse_requirements "$@"
      shift $#
      ;;

    "")
      dotfiles_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

dotfiles_completion_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_completion_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="completion"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

dotfiles_download_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_download_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="download"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --repo | -r)

        if [[ -n ${2+x} ]]; then
          args['--repo']="$2"
          shift
          shift
        else
          printf "%s\n" "--repo requires an argument: --repo, -r REPO" >&2
          exit 1
        fi
        ;;

      --branch | -b)

        if [[ -n ${2+x} ]]; then
          args['--branch']="$2"
          shift
          shift
        else
          printf "%s\n" "--branch requires an argument: --branch, -b BRANCH" >&2
          exit 1
        fi
        ;;

      --ssh)

        args['--ssh']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['target']:-} ]] || args['target']="~/.dotfiles"
  [[ -n ${args['--repo']:-} ]] || args['--repo']="Nitestack/dotfiles"
  [[ -n ${args['--branch']:-} ]] || args['--branch']="master"

}

dotfiles_install_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="install"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --one-shot)

        args['--one-shot']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['sourceDir']+x} ]]; then
          args['sourceDir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['sourceDir']:-} ]] || args['sourceDir']="~/.dotfiles"

}

dotfiles_update_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v nvim >/dev/null 2>&1; then
    deps['nvim']="$(command -v nvim | head -n1)"
  else
    printf "missing dependency: nvim\n" >&2
    printf "%s\n" "Run 'bob install stable' (or 'bob install nightly' for the nightly release of Neovim) (note that this requires \`bob\` to be installed)" >&2
    exit 1
  fi

  if command -v bob >/dev/null 2>&1; then
    deps['bob']="$(command -v bob | head -n1)"
  else
    printf "missing dependency: bob\n" >&2
    printf "%s\n" "Run 'pacman -S bob' if you are on Arch Linux or otherwise 'cargo install bob-nvim' to install bob (note that this requires \`cargo\` to be installed)" >&2
    exit 1
  fi

  action="update"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --refresh-externals | -R)

        if [[ -n ${2+x} ]]; then
          args['--refresh-externals']="$2"
          shift
          shift
        else
          printf "%s\n" "--refresh-externals requires an argument: --refresh-externals, -R OPTION" >&2
          exit 1
        fi
        ;;

      --local | -l)

        args['--local']=1
        shift
        ;;

      --cli)

        args['--cli']=1
        shift
        ;;

      --nvim)

        args['--nvim']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  [[ -n ${args['--refresh-externals']:-} ]] || args['--refresh-externals']="auto"

  if [[ ${args['--refresh-externals']:-} ]] && [[ ! ${args['--refresh-externals']:-} =~ ^(always|auto|never)$ ]]; then
    printf "%s\n" "--refresh-externals must be one of: always, auto, never" >&2
    exit 1
  fi

}

dotfiles_edit_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="edit"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --neovide | -n)

        args['--neovide']=1
        shift
        ;;

      --apply | -a)

        args['--apply']=1
        shift
        ;;

      --hardlink)

        if [[ -n ${2+x} ]]; then
          args['--hardlink']="$2"
          shift
          shift
        else
          printf "%s\n" "--hardlink requires an argument: --hardlink BOOL" >&2
          exit 1
        fi
        ;;

      --watch | -w)

        args['--watch']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['target']:-} ]] || args['target']=""

  if [[ -v args['target'] && -n $(validate_file_exists "${args['target']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "TARGET" "$(validate_file_exists "${args['target']:-}")" >&2
    exit 1
  fi

  if [[ ${args['--hardlink']:-} ]] && [[ ! ${args['--hardlink']:-} =~ ^(true|false)$ ]]; then
    printf "%s\n" "--hardlink must be one of: true, false" >&2
    exit 1
  fi

}

initialize() {
  version="0.1.0"
  long_usage=''
  set -uo pipefail

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "completion") dotfiles_completion_command ;;
    "download") dotfiles_download_command ;;
    "install") dotfiles_install_command ;;
    "update") dotfiles_update_command ;;
    "edit") dotfiles_edit_command ;;
  esac
}

initialize
run "$@"
