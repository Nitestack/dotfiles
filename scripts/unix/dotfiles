#!/usr/bin/env bash
# This script was generated by bashly 1.1.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

version_command() {
  echo "$version"
}

dotfiles_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles - CLI tool for managing dotfiles with chezmoi\n"
    echo

  else
    printf "dotfiles - CLI tool for managing dotfiles with chezmoi\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles COMMAND\n"
  printf "  dotfiles [COMMAND] --help | -h\n"
  printf "  dotfiles --version | -v\n"
  echo

  printf "%s\n" "Commands:"
  printf "  %s   Download dotfiles from the internet\n" "download"
  printf "  %s   Install dotfiles with chezmoi\n" "install "
  printf "  %s   Update dotfiles with chezmoi\n" "update  "
  printf "  %s   Edit dotfiles\n" "edit    "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

dotfiles_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles download - Download dotfiles from the internet\n"
    echo

  else
    printf "dotfiles download - Download dotfiles from the internet\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles download [TARGET] [OPTIONS]\n"
  printf "  dotfiles download --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--repo, -r REPO"
    printf "    Repo to download from\n"
    printf "    Default: Nitestack/dotfiles\n"
    echo

    printf "  %s\n" "--branch, -b BRANCH"
    printf "    Branch to download from\n"
    printf "    Default: master\n"
    echo

    printf "  %s\n" "--ssh"
    printf "    Use SSH instead of HTTPS\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "TARGET"
    printf "    Target directory to download to\n"
    printf "    Default: ~/.dotfiles\n"
    echo

  fi
}

dotfiles_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles install - Install dotfiles with chezmoi\n"
    echo

  else
    printf "dotfiles install - Install dotfiles with chezmoi\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles install [SOURCEDIR] [OPTIONS]\n"
  printf "  dotfiles install --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--one-shot"
    printf "    Attempts to install your dotfiles with chezmoi and then remove all traces of\n    chezmoi from the system. This is useful for setting up temporary\n    environments (e.g. Docker containers).\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "SOURCEDIR"
    printf "    Source directory of dotfiles\n"
    printf "    Default: ~/.dotfiles\n"
    echo

  fi
}

dotfiles_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles update - Update dotfiles with chezmoi\n"
    echo

  else
    printf "dotfiles update - Update dotfiles with chezmoi\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles update [OPTIONS]\n"
  printf "  dotfiles update --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--refresh-externals, -R OPTION"
    printf "    Refresh external cache. This defaults to auto.\n"
    printf "    Allowed: always, auto, never\n"
    printf "    Default: auto\n"
    echo

    printf "  %s\n" "--local, -l"
    printf "    Apply local changes with \`chezmoi apply\`.\n"
    echo

    printf "  %s\n" "--cli"
    printf "    Update the CLI itself. This defaults to false.\n"
    echo

    printf "  %s\n" "--nvim"
    printf "    Update Neovim plugins, Mason packages and sync lazy-lock.json file if it\n    exists.\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

dotfiles_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotfiles edit - Edit dotfiles\n"
    echo

  else
    printf "dotfiles edit - Edit dotfiles\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotfiles edit [TARGET] [OPTIONS]\n"
  printf "  dotfiles edit --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--neovide, -n"
    printf "    Use Neovide (Neovim GUI) instead of Neovim\n"
    echo

    printf "  %s\n" "--apply, -a"
    printf "    Apply target immediately after editing. Ignored if there are no targets.\n"
    echo

    printf "  %s\n" "--hardlink BOOL"
    printf "    Invoke the editor with a hard link to the source file with a name matching\n    the target filename. This can help the editor determine the type of the file\n    correctly. This is the default.\n"
    printf "    Allowed: true, false\n"
    echo

    printf "  %s\n" "--watch, -w"
    printf "    Automatically apply changes when files are saved\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "TARGET"
    printf "    Target file to edit\n"
    printf "    Default: \n"
    echo

  fi
}

normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

expand_tilde() {
	local path="$1"
	eval echo "${path}"
}

log_color() {
	color_code="$1"
	shift

	printf "\033[${color_code}m%s\033[0m\n" "$*" >&2
}
log_red() {
	log_color "0;31" "$@"
}
log_blue() {
	log_color "0;34" "$@"
}
log_yellow() {
	log_color "0;33" "$@"
}
log_green() {
	log_color "0;32" "$@"
}

log_task() {
	log_blue "" "$@"
}
log_manual_action() {
	log_red "" "$@"
}
log_error() {
	log_red "" "$@"
}
log_info() {
	log_blue "" "$@"
}
log_success() {
	log_green "" "$@"
}
log_command() {
	log_yellow "" "$@"
}
command_exec() {
	"$@" || log_error "Command failed: $*"
}
error() {
	log_error "$@"
	exit 1
}

validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

dotfiles_download_command() {
  log_task "Downloading dotfiles"

  dotfiles_dir=$(expand_tilde "${args[target]}")
  repo=${args[--repo]}
  branch=${args[--branch]}
  ssh=${args[--ssh]}

  if [[ -n "${ssh}" ]]; then
  	remote="git@github.com:${repo}.git"
  else
  	remote="https://github.com/${repo}.git"
  fi

  if [[ -d "${dotfiles_dir}" ]]; then
  	path=$(realpath "${dotfiles_dir}")

  	log_task "Cleaning '${path}' with '${remote}' at branch '${branch}'"
  	git="git -C ${path}"
  	if ${git} remote | grep -q "^origin$"; then
  		${git} remote set-url origin "${remote}"
  	else
  		${git} remote add origin "${remote}"
  	fi
  	${git} checkout -B "${branch}"
  	${git} fetch origin "${branch}"
  	${git} reset --hard FETCH_HEAD
  	${git} clean -fdx
  	unset path remote branch git
  else
  	log_task "Cloning '${repo}' at branch '${branch}' to '${dotfiles_dir}'"
  	command_exec git clone -b "${branch}" "${remote}" "${dotfiles_dir}"
  fi

  log_success "Dotfiles downloaded to '${dotfiles_dir}'"

}

dotfiles_install_command() {
  log_task "Installing dotfiles"

  sourceDir=$(expand_tilde "${args[sourceDir]}")

  set -- --source="${sourceDir}" --verbose=false

  if [[ -n "${args["--one-shot"]}" ]]; then
  	set -- "$@" --one-shot
  else
  	set -- "$@" --apply
  fi

  command_exec chezmoi init "$@"

  log_success "Installed dotfiles"

}

dotfiles_update_command() {
  log_task "Updating dotfiles"

  if [[ -n "${args[--local]}" ]]; then
  	set -- apply
  else
  	set -- update
  fi

  if [[ -n "${args["--refresh-externals"]}" ]]; then
  	set -- "$@" --refresh-externals="${args["--refresh-externals"]}"
  fi

  chezmoi "$@" || error "Failed to update dotfiles"
  log_success "Updated dotfiles"

  if [[ -n "${args["--cli"]}" ]]; then
  	script_dir="$(cd -P -- "$(dirname -- "$(command -v -- "$0")")" && pwd -P)/dotfiles"
  	if [[ ! -f "${script_dir}" ]]; then
  		error "Could not find '${script_dir}'"
  	fi

  	updated_script_dir=$(realpath "$(chezmoi source-path)/../scripts/unix/dotfiles")
  	if [[ ! -f "${updated_script_dir}" ]]; then
  		error "Could not find '${updated_script_dir}'"
  	fi

  	if [[ "${script_dir}" == "${updated_script_dir}" ]]; then
  		log_success "The CLI is already up to date"
  		exit 0
  	fi

  	log_task "Updating CLI"
  	cp -f "${updated_script_dir}" "${script_dir}" || error "Failed to sync 'dotfiles'"
  	log_success "Updated the CLI to the latest version"
  fi

  if [[ -n "${args["--nvim"]}" ]]; then
  	log_task "Updating Neovim"
  	bob update --all || error "Failed to update Neovim"
  	log_success "Updated Neovim to the latest version"

  	log_task "Updating Neovim plugins"
  	nvim --headless -c "Lazy! sync" +qa || error "Failed to update Neovim plugins"
  	log_success "Updated Neovim plugins"

  	log_task "Updating Mason packages"
  	nvim --headless -c "lua vim.schedule(function() vim.api.nvim_create_autocmd('User', { pattern = 'MasonToolsUpdateCompleted', command = 'qa' }); require('mason-tool-installer').check_install(true) end)" || error "Failed to update Mason packages"
  	log_success "Updated Mason packages"

  	log_task "Syncing 'lazy.lock.json' file"
  	source_path=$(chezmoi source-path)
  	lazy_lock_path=$(find "${source_path}" -type f -name "*lazy-lock.json" -print -quit)
  	if [[ ! -f "${lazy_lock_path}" ]]; then
  		error "Could not find 'lazy-lock.json' file in '${source_path}'"
  	fi
  	config_path="${XDG_CONFIG_HOME:-${HOME}/.config}/nvim"
  	updated_lazy_lock_path=$(find "${config_path}" -type f -name "*lazy-lock.json" -print -quit)
  	if [[ ! -f "${updated_lazy_lock_path}" ]]; then
  		error "Could not find 'lazy-lock.json' file in '${config_path}'"
  	fi
  	cp -f "${updated_lazy_lock_path}" "${lazy_lock_path}" || error "Failed to sync 'lazy-lock.json' file"
  	log_success "Synced 'lazy-lock.json' file"

  	log_task "Committing 'lazy-lock.json' file"
  	if git diff --quiet --exit-code -- "${lazy_lock_path}"; then
  		log_info "No changes in 'lazy-lock.json' file. Skip committing."
  		exit 0
  	fi
  	current_path=$(pwd)
  	cd "$(realpath "$(chezmoi source-path)/..")" || error "Failed to set current path to '$(chezmoi source-path)/..'"
  	git add "${lazy_lock_path}" || error "Failed to add 'lazy-lock.json' file to git"
  	git commit "${lazy_lock_path}" -m "chore(nvim): update lazy-lock.json" || error "Failed to commit 'lazy-lock.json' file"
  	log_success "Committed 'lazy-lock.json' file"
  	cd "${current_path}" || error "Failed to set current path to '${current_path}'"
  fi

}

dotfiles_edit_command() {
  #!/usr/bin/env bash

  if [[ "${#args[@]}" -eq 0 ]]; then
  	cd "$(realpath "$(chezmoi source-path)/..")" || exit 1

  	if [[ -n "${args[--neovide]}" ]] && command -v neovide &>/dev/null; then
  		neovide
  	elif command -v nvim &>/dev/null; then
  		nvim
  	fi
  else
  	set -- "${args[target]}"

  	if [[ -n "${args[--apply]}" ]]; then
  		set -- "$@" --apply
  	fi
  	if [[ -n "${args[--hardlink]}" ]]; then
  		set -- "$@" --hardlink="${args[--hardlink]}"
  	fi
  	if [[ -n "${args[--watch]}" ]]; then
  		set -- "$@" --watch
  	fi

  	chezmoi edit "$@"
  fi

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dotfiles_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v chezmoi >/dev/null 2>&1; then
    deps['chezmoi']="$(command -v chezmoi | head -n1)"
  else
    printf "missing dependency: chezmoi\n" >&2
    printf "%s\n" "Visit 'https://www.chezmoi.io/install' to install chezmoi" >&2
    exit 1
  fi

  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    printf "%s\n" "Visit 'https://git-scm.com/downloads' to install git" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    download)
      action="download"
      shift
      dotfiles_download_parse_requirements "$@"
      shift $#
      ;;

    install)
      action="install"
      shift
      dotfiles_install_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      dotfiles_update_parse_requirements "$@"
      shift $#
      ;;

    edit)
      action="edit"
      shift
      dotfiles_edit_parse_requirements "$@"
      shift $#
      ;;

    "")
      dotfiles_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

dotfiles_download_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_download_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="download"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --repo | -r)

        if [[ -n ${2+x} ]]; then
          args['--repo']="$2"
          shift
          shift
        else
          printf "%s\n" "--repo requires an argument: --repo, -r REPO" >&2
          exit 1
        fi
        ;;

      --branch | -b)

        if [[ -n ${2+x} ]]; then
          args['--branch']="$2"
          shift
          shift
        else
          printf "%s\n" "--branch requires an argument: --branch, -b BRANCH" >&2
          exit 1
        fi
        ;;

      --ssh)

        args['--ssh']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['target']:-} ]] || args['target']="~/.dotfiles"
  [[ -n ${args['--repo']:-} ]] || args['--repo']="Nitestack/dotfiles"
  [[ -n ${args['--branch']:-} ]] || args['--branch']="master"

}

dotfiles_install_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="install"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --one-shot)

        args['--one-shot']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['sourceDir']+x} ]]; then
          args['sourceDir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['sourceDir']:-} ]] || args['sourceDir']="~/.dotfiles"

}

dotfiles_update_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v nvim >/dev/null 2>&1; then
    deps['nvim']="$(command -v nvim | head -n1)"
  else
    printf "missing dependency: nvim\n" >&2
    printf "%s\n" "Run 'bob install stable' (or 'bob install nightly' for the nightly release of Neovim) (note that this requires \`bob\` to be installed)" >&2
    exit 1
  fi

  if command -v bob >/dev/null 2>&1; then
    deps['bob']="$(command -v bob | head -n1)"
  else
    printf "missing dependency: bob\n" >&2
    printf "%s\n" "Run 'pacman -S bob' if you are on Arch Linux or otherwise 'cargo install bob-nvim' to install bob (note that this requires \`cargo\` to be installed)" >&2
    exit 1
  fi

  action="update"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --refresh-externals | -R)

        if [[ -n ${2+x} ]]; then
          args['--refresh-externals']="$2"
          shift
          shift
        else
          printf "%s\n" "--refresh-externals requires an argument: --refresh-externals, -R OPTION" >&2
          exit 1
        fi
        ;;

      --local | -l)

        args['--local']=1
        shift
        ;;

      --cli)

        args['--cli']=1
        shift
        ;;

      --nvim)

        args['--nvim']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  [[ -n ${args['--refresh-externals']:-} ]] || args['--refresh-externals']="auto"

  if [[ ${args['--refresh-externals']:-} ]] && [[ ! ${args['--refresh-externals']:-} =~ ^(always|auto|never)$ ]]; then
    printf "%s\n" "--refresh-externals must be one of: always, auto, never" >&2
    exit 1
  fi

}

dotfiles_edit_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotfiles_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="edit"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --neovide | -n)

        args['--neovide']=1
        shift
        ;;

      --apply | -a)

        args['--apply']=1
        shift
        ;;

      --hardlink)

        if [[ -n ${2+x} ]]; then
          args['--hardlink']="$2"
          shift
          shift
        else
          printf "%s\n" "--hardlink requires an argument: --hardlink BOOL" >&2
          exit 1
        fi
        ;;

      --watch | -w)

        args['--watch']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['target']:-} ]] || args['target']=""

  if [[ -v args['target'] && -n $(validate_file_exists "${args['target']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "TARGET" "$(validate_file_exists "${args['target']:-}")" >&2
    exit 1
  fi

  if [[ ${args['--hardlink']:-} ]] && [[ ! ${args['--hardlink']:-} =~ ^(true|false)$ ]]; then
    printf "%s\n" "--hardlink must be one of: true, false" >&2
    exit 1
  fi

}

initialize() {
  version="0.1.0"
  long_usage=''
  set -e

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "download") dotfiles_download_command ;;
    "install") dotfiles_install_command ;;
    "update") dotfiles_update_command ;;
    "edit") dotfiles_edit_command ;;
  esac
}

initialize
run "$@"
